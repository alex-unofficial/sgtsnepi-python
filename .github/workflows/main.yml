name: Build Wheels (Linux + macOS + Windows)
on:
  push:
    branches: [ "master" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "master" ]
jobs:
  build-wheels:
    name: Build wheels on ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v6

      - name: Build Wheels using cibuildwheel
        uses: pypa/cibuildwheel@v3.3.1
        env:
          # Skip Python versions older than 3.9 (matches pyproject.toml python-requires)
          # This allows automatic building for new Python versions as they're added to cibuildwheel
          CIBW_SKIP: "cp38-* *-win32 *-musllinux_*"
          
          CIBW_BEFORE_BUILD_MACOS: "brew update && brew install fftw"
          CIBW_BEFORE_BUILD_LINUX: "yum install -y fftw-devel"
          CIBW_BEFORE_BUILD_WINDOWS: >
            pip install delvewheel &&
            echo "=== BUILD DIAGNOSTICS ===" &&
            echo "Compiler check:" &&
            gcc --version || echo "gcc not found" &&
            g++ --version || echo "g++ not found" &&
            echo "FFTW location:" &&
            ls -la C:/fftw/libfftw* || echo "FFTW files not found" &&
            ls -la C:/fftw/fftw3.h || echo "FFTW header not found"
          
          # Build FFTW from source with current MinGW toolchain for ABI compatibility
          CIBW_BEFORE_ALL_WINDOWS: >
            C:\\msys64\\usr\\bin\\bash.exe -lc "
            echo '=== Installing MinGW toolchain and wget ===' &&
            pacman -Sy --noconfirm mingw-w64-x86_64-toolchain wget &&
            export PATH=/mingw64/bin:\$PATH &&
            echo '=== BUILDING FFTW 3.3.10 FROM SOURCE ===' &&
            cd /tmp &&
            wget http://www.fftw.org/fftw-3.3.10.tar.gz -O fftw.tar.gz &&
            tar -xzf fftw.tar.gz &&
            cd fftw-3.3.10 &&
            echo '=== Building double precision FFTW ===' &&
            ./configure --prefix=/usr/local --with-our-malloc16 --enable-shared --disable-static --enable-threads --with-combined-threads --enable-portable-binary --enable-sse2 --with-incoming-stack-boundary=2 &&
            make -j4 &&
            make install &&
            echo '=== Building single precision FFTW ===' &&
            make distclean &&
            ./configure --prefix=/usr/local --enable-float --with-our-malloc16 --enable-shared --disable-static --enable-threads --with-combined-threads --enable-portable-binary --enable-sse2 --with-incoming-stack-boundary=2 &&
            make -j4 &&
            make install &&
            echo '=== Installing to C:/fftw ===' &&
            mkdir -p /c/fftw &&
            cp /usr/local/bin/libfftw*.dll /c/fftw/ &&
            cp /usr/local/include/fftw3.h /c/fftw/ &&
            cp /usr/local/lib/libfftw*.dll.a /c/fftw/ &&
            echo '=== FFTW Build Complete ===' &&
            ls -lh /c/fftw/
            "
          
          # Environment variables for Windows to use built FFTW
          CIBW_ENVIRONMENT_WINDOWS: >
            CFLAGS=-IC:/fftw
            CXXFLAGS=-IC:/fftw
            LDFLAGS=-LC:/fftw
          
          # Use delvewheel to bundle FFTW DLLs
          CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "delvewheel repair --add-path C:/fftw -w {dest_dir} {wheel}"

          # Only build 64-bit Linux wheels
          CIBW_ARCHS_LINUX: "x86_64"

          # Force a valid manylinux image (avoid date-based tags)
          CIBW_MANYLINUX_X86_64_IMAGE: "quay.io/pypa/manylinux2014_x86_64:latest"

          # Force the wheel's minimum macOS version to 15.0
          MACOSX_DEPLOYMENT_TARGET: "15.0"
        with:
          output-dir: dist

      - name: Show built wheels
        run: |
          echo "=== BUILT WHEELS ===" 
          ls -lh dist
          echo ""
          echo "=== INSPECTING WINDOWS WHEELS ==="
          for wheel in dist/*win*.whl; do
            if [ -f "$wheel" ]; then
              echo "Inspecting: $(basename $wheel)"
              ls -lh "$wheel"
              unzip -l "$wheel" | grep -E "(\.pyd|\.dll|\.libs)" | head -30
              echo ""
            fi
          done || echo "No Windows wheels found or inspection failed"
        shell: bash

      - name: Upload build artifacts
        uses: actions/upload-artifact@v6
        with:
          # We'll name each artifact distinctly, so we can download them all later
          name: cibw-wheels-${{ matrix.os }}-${{ strategy.job-index }}
          path: dist/*.whl

  # Test each platform's wheels independently as soon as they're built
  test-linux-wheels:
    name: Test Linux wheels (Python ${{ matrix.python-version }})
    needs: [build-wheels]
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.12']
    
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Download Linux wheels
        uses: actions/download-artifact@v7
        with:
          pattern: cibw-wheels-ubuntu-latest-*
          path: dist
          merge-multiple: true
      
      - name: Install wheel and dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install numpy scipy nextprod
          # Get Python version tag
          python_tag=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          echo "Looking for wheel with tag: $python_tag"
          # Find and install matching wheel
          wheel=$(ls dist/*-${python_tag}-*.whl 2>/dev/null | head -n 1)
          if [ -n "$wheel" ]; then
            echo "Installing: $wheel"
            python -m pip install "$wheel"
          else
            echo "ERROR: No wheel found for $python_tag"
            ls -la dist/
            exit 1
          fi
      
      - name: Test import
        run: |
          cd /tmp
          python -c "from sgtsnepi import sgtsnepi; print('✓ Successfully imported sgtsnepi')"
          python -c "from sgtsnepi.sgtsne import sgtsnepi; print('✓ Successfully imported sgtsnepi function')"
          python -c "from sgtsnepi import _sgtsnepi; print('✓ Successfully imported _sgtsnepi C extension')"

  test-macos-wheels:
    name: Test macOS wheels (Python ${{ matrix.python-version }})
    needs: [build-wheels]
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.12']
    
    runs-on: macos-latest
    
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Download macOS wheels
        uses: actions/download-artifact@v7
        with:
          pattern: cibw-wheels-macos-latest-*
          path: dist
          merge-multiple: true
      
      - name: Install wheel and dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install numpy scipy nextprod
          # Get Python version tag
          python_tag=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          echo "Looking for wheel with tag: $python_tag"
          # Find and install matching wheel
          wheel=$(ls dist/*-${python_tag}-*.whl 2>/dev/null | head -n 1)
          if [ -n "$wheel" ]; then
            echo "Installing: $wheel"
            python -m pip install "$wheel"
          else
            echo "ERROR: No wheel found for $python_tag"
            ls -la dist/
            exit 1
          fi
      
      - name: Test import
        run: |
          cd /tmp
          python -c "from sgtsnepi import sgtsnepi; print('✓ Successfully imported sgtsnepi')"
          python -c "from sgtsnepi.sgtsne import sgtsnepi; print('✓ Successfully imported sgtsnepi function')"
          python -c "from sgtsnepi import _sgtsnepi; print('✓ Successfully imported _sgtsnepi C extension')"

  test-windows-wheels:
    name: Test Windows wheels (Python ${{ matrix.python-version }})
    needs: [build-wheels]
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.12']
    
    runs-on: windows-latest
    
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Download Windows wheels
        uses: actions/download-artifact@v7
        with:
          pattern: cibw-wheels-windows-latest-*
          path: dist
          merge-multiple: true
      
      - name: Inspect wheel contents
        shell: bash
        run: |
          python -m pip install --upgrade pip
          python -m pip install zipfile-cli || pip install wheel
          
          # Get Python version tag
          python_tag=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          echo "=== Looking for wheel with tag: $python_tag ==="
          
          # Find matching wheel
          wheel=$(ls dist/*-${python_tag}-*.whl 2>/dev/null | head -n 1)
          if [ -z "$wheel" ]; then
            echo "ERROR: No wheel found for $python_tag"
            ls -la dist/
            exit 1
          fi
          
          echo "=== Found wheel: $wheel ==="
          ls -lh "$wheel"
          
          echo ""
          echo "=== Wheel contents (first 50 files): ==="
          python -m zipfile -l "$wheel" | head -50
          
          echo ""
          echo "=== Looking for DLL files in wheel: ==="
          python -m zipfile -l "$wheel" | grep -i "\.dll" || echo "No DLL files found in wheel!"
          
          echo ""
          echo "=== Looking for .libs directory (delvewheel): ==="
          python -m zipfile -l "$wheel" | grep -i "\.libs" || echo "No .libs directory found!"
      
      - name: Install wheel and dependencies
        shell: bash
        run: |
          python -m pip install numpy scipy nextprod
          
          # Get Python version tag
          python_tag=$(python -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')")
          wheel=$(ls dist/*-${python_tag}-*.whl 2>/dev/null | head -n 1)
          
          echo "=== Installing wheel: $wheel ==="
          python -m pip install "$wheel"
          echo "✓ Wheel installed successfully"
      
      - name: Test import with diagnostics
        shell: bash
        run: |
          # Create and use a clean temp directory (not $TMPDIR which can be in repo)
          TEST_DIR=$(mktemp -d)
          cd "$TEST_DIR"
          
          echo "=========================================="
          echo "COMPREHENSIVE WINDOWS DIAGNOSTICS"
          echo "=========================================="
          
          python -c "
          import sys
          import os
          import glob
          import traceback
          import subprocess
          
          print('\n=== 1. SYSTEM INFORMATION ===')
          print(f'Python version: {sys.version}')
          print(f'Python executable: {sys.executable}')
          print(f'Platform: {sys.platform}')
          import platform
          print(f'Architecture: {platform.machine()}')
          print(f'Python compiler: {platform.python_compiler()}')
          print(f'Working directory: {os.getcwd()}')
          
          print('\n=== 2. FINDING SGTSNEPI PACKAGE ===')
          try:
              import sgtsnepi
              pkg_path = os.path.dirname(sgtsnepi.__file__)
              print(f'✓ Package found at: {pkg_path}')
              
              print('\n=== 3. PACKAGE CONTENTS ===')
              for item in sorted(os.listdir(pkg_path)):
                  item_path = os.path.join(pkg_path, item)
                  if os.path.isdir(item_path):
                      print(f'  [DIR]  {item}/')
                  else:
                      size = os.path.getsize(item_path)
                      print(f'  [FILE] {item} ({size:,} bytes)')
              
              print('\n=== 4. DLL BUNDLING CHECK (.libs directory) ===')
              libs_dir = os.path.join(pkg_path, '.libs')
              print(f'Looking for: {libs_dir}')
              print(f'Exists: {os.path.exists(libs_dir)}')
              
              if os.path.exists(libs_dir):
                  print('Contents:')
                  for dll in sorted(os.listdir(libs_dir)):
                      dll_path = os.path.join(libs_dir, dll)
                      size = os.path.getsize(dll_path)
                      print(f'    {dll}: {size:,} bytes')
              else:
                  print('⚠️  WARNING: .libs directory NOT FOUND!')
                  print('    Delvewheel may not have run or bundled DLLs incorrectly')
              
              print('\n=== 5. EXTENSION MODULE CHECK ===')
              ext_pattern = os.path.join(pkg_path, '_sgtsnepi*.pyd')
              ext_files = glob.glob(ext_pattern)
              if ext_files:
                  for ext_file in ext_files:
                      size = os.path.getsize(ext_file)
                      print(f'Found extension: {os.path.basename(ext_file)} ({size:,} bytes)')
                      
                      # Try to check dependencies
                      print(f'\nAnalyzing dependencies of {os.path.basename(ext_file)}:')
                      try:
                          # Try objdump (from MinGW)
                          result = subprocess.run(
                              ['objdump', '-p', ext_file], 
                              capture_output=True, 
                              text=True, 
                              timeout=10
                          )
                          if result.returncode == 0:
                              lines = result.stdout.split('\n')
                              dll_section = False
                              print('  DLL dependencies:')
                              for line in lines:
                                  if 'DLL Name:' in line:
                                      dll_section = True
                                  if dll_section and '.dll' in line.lower():
                                      print(f'    {line.strip()}')
                                  if dll_section and line.strip() == '':
                                      break
                          else:
                              print(f'  objdump failed (exit code {result.returncode})')
                      except FileNotFoundError:
                          print('  objdump not available')
                      except Exception as e:
                          print(f'  Could not analyze: {e}')
              else:
                  print('❌ ERROR: No _sgtsnepi extension module found!')
                  print(f'   Searched for: {ext_pattern}')
              
          except ImportError as e:
              print(f'❌ Cannot find sgtsnepi package: {e}')
              print('This should not happen - package should be installed')
              sys.exit(1)
          
          print('\n=== 6. ATTEMPTING IMPORTS ===')
          
          # Test 1: Import main module
          print('\nTest 1: Import sgtsnepi module...')
          try:
              from sgtsnepi import sgtsne
              print('✅ Successfully imported sgtsnepi.sgtsne module')
          except Exception as e:
              print(f'❌ Failed to import sgtsnepi.sgtsne module')
              print(f'   Error: {e}')
              traceback.print_exc()
              print('\n=== FAILURE ANALYSIS ===')
              if 'DLL load failed' in str(e):
                  print('This is a Windows DLL loading error.')
                  error_str = str(e).lower()
                  if 'procedure' in error_str:
                      print('Error contains \"procedure not found\" - this typically means:')
                      print('  1. ABI incompatibility (different compiler versions)')
                      print('  2. Extension compiled with different MinGW than DLLs')
                      print('  3. Missing or incompatible C++ runtime libraries')
                      print('  4. Symbol name mangling differences')
                  elif 'module' in error_str or 'specified module' in error_str:
                      print('Error contains \"module not found\" - this typically means:')
                      print('  1. Required DLL not found in search path')
                      print('  2. DLL architecture mismatch (32-bit vs 64-bit)')
                      print('  3. Missing dependencies of the DLL itself')
              sys.exit(1)
          
          # Test 2: Import function
          print('\nTest 2: Import sgtsnepi function...')
          try:
              from sgtsnepi import sgtsnepi as fn
              print('✅ Successfully imported sgtsnepi function')
              print(f'   Function: {fn}')
          except Exception as e:
              print(f'❌ Failed to import sgtsnepi function')
              print(f'   Error: {e}')
              traceback.print_exc()
              sys.exit(1)
          
          # Test 3: Import C extension directly
          print('\nTest 3: Import _sgtsnepi C extension directly...')
          try:
              from sgtsnepi import _sgtsnepi
              print('✅ Successfully imported _sgtsnepi C extension')
          except Exception as e:
              print(f'❌ Failed to import _sgtsnepi C extension')
              print(f'   Error: {e}')
              traceback.print_exc()
              sys.exit(1)
          
          print('\n' + '='*50)
          print('✅ ALL TESTS PASSED!')
          print('='*50)
          "


  publish:
    needs: [build-wheels, test-linux-wheels, test-macos-wheels, test-windows-wheels]
    environment: pypi
    permissions:
      id-token: write
    runs-on: ubuntu-latest

    # Only publish on tag pushes: e.g. "v0.1.0"
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download wheels
        uses: actions/download-artifact@v7
        with:
          pattern: cibw-*
          path: dist
          merge-multiple: true

      - name: Show downloaded wheels
        run: ls -l dist

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
